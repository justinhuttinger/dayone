const express = require('express');
const axios = require('axios');
const Anthropic = require('@anthropic-ai/sdk');
const fs = require('fs').promises;
const path = require('path');
const sgMail = require('@sendgrid/mail');
require('dotenv').config();

const app = express();
app.use(express.json());

// Initialize SendGrid
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

// Initialize Anthropic (Claude)
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// Multi-location configuration
const LOCATION_CONFIG = {
  // Salem Location
  'GjtINe5Nv5RwS5BVM9gY': {
    name: 'Salem - Support System',
    apiKey: process.env.GHL_API_KEY_SALEM || process.env.GHL_API_KEY,
    fromEmail: 'programs@westcoaststrength.com',
    fromName: 'West Coast Strength - Salem'
  },
  // Add more locations here
  'LOCATION_ID_2': {
    name: 'Portland Location',
    apiKey: process.env.GHL_API_KEY_PORTLAND || process.env.GHL_API_KEY,
    fromEmail: 'programs@westcoaststrength.com',
    fromName: 'West Coast Strength - Portland'
  },
  'LOCATION_ID_3': {
    name: 'Eugene Location',
    apiKey: process.env.GHL_API_KEY_EUGENE || process.env.GHL_API_KEY,
    fromEmail: 'programs@westcoaststrength.com',
    fromName: 'West Coast Strength - Eugene'
  }
  // Add as many locations as needed
};

// Helper function to get location config
function getLocationConfig(locationId) {
  const config = LOCATION_CONFIG[locationId];
  if (!config) {
    console.warn(`No config found for location ${locationId}, using default`);
    return {
      name: 'West Coast Strength',
      apiKey: process.env.GHL_API_KEY,
      fromEmail: 'programs@westcoaststrength.com',
      fromName: 'West Coast Strength'
    };
  }
  return config;
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', service: 'PT Program Generator' });
});

// Main webhook endpoint from GHL
app.post('/webhook/generate-program', async (req, res) => {
  try {
    console.log('Received webhook:', JSON.stringify(req.body, null, 2));
    
    // Parse GHL webhook format
    const contactId = req.body.contact_id;
    const locationId = req.body.location?.id;
    
    // Map GHL field names to our format
    const formData = {
      trainerName: req.body['Service Employee'] || '',
      programGoal: req.body['Program Goal'] || 'general fitness',
      duration: (req.body['Duration'] || '8 weeks').replace(' weeks', ''),
      daysPerWeek: (req.body['Days per Week'] || '4').replace(' days a week', '').replace(' day a week', ''),
      experienceLevel: (req.body['Experience Level'] || 'intermediate').toLowerCase(),
      equipment: req.body['Equipment'] || 'full gym',
      weight: req.body['Weight'] || '',
      height: req.body['Height'] || '',
      bodyFat: (req.body['Body Fat'] || '').replace('%', ''),
      bmr: req.body['BMR'] || '',
      neckLimitation: Array.isArray(req.body['Neck Limitation']) && req.body['Neck Limitation'].includes('Yes'),
      shoulderLimitation: Array.isArray(req.body['Shoulder Limitation']) && req.body['Shoulder Limitation'].includes('Yes'),
      elbowWristLimitation: Array.isArray(req.body['Elbow Wrist Limitation']) && req.body['Elbow Wrist Limitation'].includes('Yes'),
      lowerBackLimitation: Array.isArray(req.body['Lower Back Limitation']) && req.body['Lower Back Limitation'].includes('Yes'),
      hipLimitation: Array.isArray(req.body['Hip Limitation']) && req.body['Hip Limitation'].includes('Yes'),
      kneeLimitation: Array.isArray(req.body['Knee Limitation']) && req.body['Knee Limitation'].includes('Yes'),
      ankleLimitation: Array.isArray(req.body['Ankle Limitation']) && req.body['Ankle Limitation'].includes('Yes'),
      otherLimitations: req.body['Other Limitations'] || ''
    };
    
    console.log('Parsed formData:', JSON.stringify(formData, null, 2));
    
    // Quick response to GHL
    res.status(200).json({ message: 'Program generation started' });
    
    // Process asynchronously
    generateAndSendProgram(contactId, locationId, formData);
    
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Main program generation function
async function generateAndSendProgram(contactId, locationId, formData) {
  try {
    console.log(`Starting program generation for contact: ${contactId}`);
    
    // Step 1: Fetch contact data from GHL
    const contactData = await fetchGHLContact(contactId, locationId);
    console.log(`Fetched contact: ${contactData.name}`);
    
    // Step 2: Generate program with Claude AI
    const programContent = await generateProgramWithAI(contactData, formData);
    console.log('Program generated by AI');
    
    // Step 3: Add trainer name to program content (so it's available in formatting)
    programContent.trainerName = formData.trainerName || '';
    
    // Step 4: Create PDF from template
    const pdfBuffer = await generatePDF(contactData, programContent);
    console.log('PDF created');
    
    // Step 5: Email PDF to client
    await sendProgramEmail(contactData, pdfBuffer);
    console.log(`Program sent to: ${contactData.email}`);
    
    // Step 6: Upload PDF to GHL contact record (optional)
    // await uploadToGHL(contactId, locationId, pdfBuffer);
    
  } catch (error) {
    console.error('Program generation error:', error);
    // Send error notification
    await sendErrorNotification(error, contactId);
  }
}

// Fetch contact data from GHL
async function fetchGHLContact(contactId, locationId) {
  // Get location-specific API key
  const locationConfig = getLocationConfig(locationId);
  const apiKey = locationConfig.apiKey;
  
  console.log(`Fetching contact from location: ${locationConfig.name}`);
  
  const response = await axios.get(
    `https://services.leadconnectorhq.com/contacts/${contactId}`,
    {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Version': '2021-07-28'
      }
    }
  );
  
  const contact = response.data.contact;
  
  return {
    id: contact.id,
    name: contact.name || 'Client',
    firstName: contact.firstName || '',
    lastName: contact.lastName || '',
    email: contact.email,
    phone: contact.phone,
    customFields: contact.customField || {},
    tags: contact.tags || [],
    locationId: locationId,
    locationName: locationConfig.name
  };
}

// Generate program using Claude AI
async function generateProgramWithAI(contactData, formData) {
  const prompt = buildPrompt(contactData, formData);
  
  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 8000,
    messages: [
      {
        role: 'user',
        content: prompt
      }
    ]
  });
  
  const responseText = message.content[0].text;
  
  // Parse the structured response
  try {
    // Remove markdown code blocks if present
    let cleanedResponse = responseText.trim();
    
    // Check for markdown JSON code blocks and extract
    const jsonMatch = cleanedResponse.match(/```json\s*\n?([\s\S]*?)\n?```/);
    if (jsonMatch) {
      cleanedResponse = jsonMatch[1];
      console.log('Extracted from markdown json block');
    } else {
      // Try to find just ``` code blocks
      const codeMatch = cleanedResponse.match(/```\s*\n?([\s\S]*?)\n?```/);
      if (codeMatch) {
        cleanedResponse = codeMatch[1];
        console.log('Extracted from markdown code block');
      }
    }
    
    // Try to parse
    const parsed = JSON.parse(cleanedResponse.trim());
    
    // Log what we got
    console.log('✅ Successfully parsed program JSON');
    console.log('Has weekTemplate?', !!parsed.weekTemplate);
    console.log('Has weeks?', !!parsed.weeks);
    console.log('Has mealPlan?', !!parsed.mealPlan);
    if (parsed.weekTemplate) {
      console.log('Number of workouts:', parsed.weekTemplate.workouts?.length || 0);
    }
    
    return parsed;
  } catch (e) {
    console.error('❌ JSON parse failed:', e.message);
    console.log('First 500 chars of response:', responseText.substring(0, 500));
    
    // Try to find and extract just the JSON object
    const jsonStart = responseText.indexOf('{');
    const jsonEnd = responseText.lastIndexOf('}');
    
    if (jsonStart !== -1 && jsonEnd !== -1) {
      try {
        const extracted = responseText.substring(jsonStart, jsonEnd + 1);
        const parsed = JSON.parse(extracted);
        console.log('✅ Successfully extracted and parsed JSON');
        return parsed;
      } catch (e2) {
        console.error('❌ Extraction also failed:', e2.message);
      }
    }
    
    // Last resort: return as text
    console.error('⚠️ Falling back to text mode - PDF will show raw JSON');
    return { programText: responseText };
  }
}

// Build AI prompt with full personalization
function buildPrompt(contactData, formData) {
  const {
    trainerName = '',
    programGoal = 'general fitness',
    duration = '8',
    daysPerWeek = '4',
    experienceLevel = 'intermediate',
    equipment = 'full gym',
    weight = '',
    height = '',
    bodyFat = '',
    bmr = '',
    neckLimitation = false,
    shoulderLimitation = false,
    elbowWristLimitation = false,
    lowerBackLimitation = false,
    hipLimitation = false,
    kneeLimitation = false,
    ankleLimitation = false,
    otherLimitations = ''
  } = formData || {};
  
  // Build limitations summary
  const limitations = [];
  if (neckLimitation) limitations.push('neck/cervical');
  if (shoulderLimitation) limitations.push('shoulder');
  if (elbowWristLimitation) limitations.push('elbow/wrist');
  if (lowerBackLimitation) limitations.push('lower back');
  if (hipLimitation) limitations.push('hip');
  if (kneeLimitation) limitations.push('knee');
  if (ankleLimitation) limitations.push('ankle/foot');
  if (otherLimitations) limitations.push(otherLimitations);
  
  const limitationsText = limitations.length > 0 
    ? `MOVEMENT LIMITATIONS: ${limitations.join(', ')}. For each limitation, modify exercises to use pain-free alternatives or easier progressions. For example: shoulder limitations = use landmine press instead of overhead press; knee limitations = reduce squat depth or use leg press; lower back limitations = avoid heavy loaded spinal flexion/extension.`
    : 'No reported movement limitations.';
  
  return `You are an expert personal trainer creating a fully customized training program.

CLIENT INFORMATION:
- Name: ${contactData.firstName} ${contactData.lastName}
- Trainer: ${trainerName || 'To be assigned'}
- Weight: ${weight} lbs
- Height: ${height} inches
- Body Fat: ${bodyFat}%
- Basal Metabolic Rate: ${bmr} calories/day

PROGRAM REQUIREMENTS:
- Goal: ${programGoal}
- Duration: ${duration} weeks
- Training Days per Week: ${daysPerWeek}
- Experience Level: ${experienceLevel}
- Available Equipment: ${equipment}

${limitationsText}

YOUR TASK: Generate ONE WEEK of training (repeated for ${duration} weeks).

Return in JSON format:

{
  "programOverview": "2-3 sentence overview of training approach and how it addresses their specific goal and limitations",
  "inbodyStats": {
    "weight": "${weight}",
    "height": "${height}",
    "bodyFat": "${bodyFat}",
    "bmr": "${bmr}"
  },
  "weekTemplate": {
    "workouts": [
      {
        "day": 1,
        "title": "Workout name (e.g., Upper Body Strength)",
        "exercises": [
          {
            "name": "Exercise name (modified for any limitations)",
            "sets": "3",
            "reps": "8-10",
            "rest": "90 seconds",
            "notes": "Form cues, modifications for limitations if applicable",
            "videoUrl": "Optional: URL to instructional video (leave empty if not available)"
          }
        ]
      }
    ]
  },
  "progressionNotes": "How to progress week to week (increase weight, reps, etc.)",
  "generalNotes": "Important reminders, warm-up guidance, cool-down"
}
            "amount": "Serving size",

CRITICAL INSTRUCTIONS:
1. Create ${daysPerWeek} distinct workouts that form a complete training split
2. MODIFY exercises based on limitations - use safer alternatives, reduced ROM, or easier progressions
3. Include specific form cues and technique notes for each exercise
4. Return ONLY valid JSON. No markdown code blocks. No text before or after the JSON.`;
}
// Generate PDF from HTML template
async function generatePDF(contactData, programContent) {
  // Load HTML template
  const templatePath = path.join(__dirname, 'templates', 'program-template.html');
  let htmlTemplate = await fs.readFile(templatePath, 'utf8');
  
  // Load and encode logo as base64
  const logoPath = path.join(__dirname, 'templates', 'logo.png');
  const logoBuffer = await fs.readFile(logoPath);
  const logoBase64 = logoBuffer.toString('base64');
  
  // Generate the program content HTML first
  let programHTML = formatProgramHTML(contactData, programContent);
  
  // THEN replace the logo placeholder in the program content
  programHTML = programHTML.replace(/{{logoBase64}}/g, logoBase64);
  
  // Replace placeholders in template
  htmlTemplate = htmlTemplate
    .replace(/{{programContent}}/g, programHTML);
  
  console.log('Generated HTML length:', htmlTemplate.length);
  console.log('First 200 chars:', htmlTemplate.substring(0, 200));
  
  // Generate PDF using PDFShift API with margins
  const response = await axios.post(
    'https://api.pdfshift.io/v3/convert/pdf',
    {
      source: htmlTemplate,
      landscape: false,
      use_print: true,
      margin: {
        top: '0.5in',
        bottom: '0.5in',
        left: '0.5in',
        right: '0.5in'
      }
    },
    {
      auth: {
        username: 'api',
        password: process.env.PDFSHIFT_API_KEY
      },
      responseType: 'arraybuffer'
    }
  );
  
  return Buffer.from(response.data);
}

// Format program content as HTML matching WCS Day 1 Program style
function formatProgramHTML(contactData, programContent) {
  if (!programContent.weekTemplate && !programContent.weeks) {
    return `<div class="program-text">${programContent.programText || 'Program content'}</div>`;
  }
  
  let html = '';
  
  // Page 1: Overview/Core Concepts with InBody Stats
  html += `
    <div class="page">
      <img src="data:image/png;base64,{{logoBase64}}" class="logo-image" alt="WCS Logo">
      
      <div class="page-header">
        <div class="header-left">
          <h1>WEST COAST STRENGTH</h1>
          <h2>TRAINING PROGRAM</h2>
        </div>
        <div class="header-right">
          <p>TRAINER: ${programContent.trainerName || ''}</p>
          <p>CLIENT: ${contactData.firstName} ${contactData.lastName}</p>
        </div>
      </div>
      
      <div class="core-concepts">
        <h3>CORE CONCEPTS:</h3>
        <div class="core-concepts-content">
          ${programContent.programOverview ? `<p>${programContent.programOverview}</p>` : ''}
          ${programContent.progressionNotes ? `<p><strong>Progression:</strong> ${programContent.progressionNotes}</p>` : ''}
          ${programContent.generalNotes ? `<p><strong>Important Notes:</strong> ${programContent.generalNotes}</p>` : ''}
        </div>
        
        ${programContent.inbodyStats ? `
          <h3 style="margin-top: 40px;">INBODY METRICS:</h3>
          <div class="core-concepts-content">
            <p><strong>Weight:</strong> ${programContent.inbodyStats.weight} lbs | <strong>Height:</strong> ${programContent.inbodyStats.height} inches</p>
            <p><strong>Body Fat:</strong> ${programContent.inbodyStats.bodyFat}% | <strong>Basal Metabolic Rate:</strong> ${programContent.inbodyStats.bmr} calories/day</p>
          </div>
        ` : ''}
      </div>
    </div>
  `;
  
  // Get the workout template
  const workouts = programContent.weekTemplate?.workouts || programContent.weeks?.[0]?.workouts || [];
  
  // Generate workout pages - one page per workout
  workouts.forEach(workout => {
    html += `
      <div class="page">
        <img src="data:image/png;base64,{{logoBase64}}" class="logo-image" alt="WCS Logo">
        
        <div class="page-header">
          <div class="header-left">
            <h1>WEST COAST STRENGTH</h1>
            <h2>DAY ${workout.day} - ${workout.title.toUpperCase()}</h2>
          </div>
          <div class="header-right">
            <p>TRAINER: ${programContent.trainerName || ''}</p>
            <p>CLIENT: ${contactData.firstName} ${contactData.lastName}</p>
          </div>
        </div>
        
        <table class="workout-table">
    `;
    
    // Add exercises as table rows
    workout.exercises.forEach(exercise => {
      const setsReps = `${exercise.sets} x ${exercise.reps}`;
      const notes = exercise.notes || '';
      const videoUrl = exercise.videoUrl || '';
      
      // Generate QR code if video URL exists
      let qrCodeHTML = '';
      if (videoUrl) {
        // QR code API - generates QR code image from URL
        qrCodeHTML = `<br><img src="https://api.qrserver.com/v1/create-qr-code/?size=60x60&data=${encodeURIComponent(videoUrl)}" alt="Video QR" style="margin-top: 5px;">`;
      }
      
      html += `
        <tr>
          <td>
            <strong>${exercise.name}</strong>
            ${notes ? `<br><span style="font-size: 11px; color: #666;">${notes}</span>` : ''}
            ${qrCodeHTML}
          </td>
          <td>${setsReps}</td>
        </tr>
      `;
    });
    
    html += `
        </table>
      </div>
    `;
  });
  
  return html;
}

// Send program via email
async function sendProgramEmail(contactData, pdfBuffer) {
  // Get location-specific email config
  const locationConfig = getLocationConfig(contactData.locationId);
  
  const msg = {
    to: contactData.email,
    from: {
      email: locationConfig.fromEmail,
      name: locationConfig.fromName
    },
    subject: `Your Personalized Training Program - ${contactData.firstName}`,
    text: `Hi ${contactData.firstName},\n\nYour customized training program from ${locationConfig.name} is attached. Please review it carefully and reach out if you have any questions.\n\nLet's crush these goals!\n\n${locationConfig.fromName}`,
    html: `
      <p>Hi ${contactData.firstName},</p>
      <p>Your customized training program from <strong>${locationConfig.name}</strong> is attached. Please review it carefully and reach out if you have any questions.</p>
      <p><strong>Let's crush these goals!</strong></p>
      <p>${locationConfig.fromName}</p>
    `,
    attachments: [
      {
        content: pdfBuffer.toString('base64'),
        filename: `Training_Program_${contactData.firstName}_${contactData.lastName}.pdf`,
        type: 'application/pdf',
        disposition: 'attachment'
      }
    ]
  };
  
  await sgMail.send(msg);
}

// Send error notification
async function sendErrorNotification(error, contactId) {
  const msg = {
    to: process.env.ADMIN_EMAIL || 'justin@westcoaststrength.com',
    from: process.env.FROM_EMAIL || 'programs@westcoaststrength.com',
    subject: 'PT Program Generator Error',
    text: `Error generating program for contact ${contactId}:\n\n${error.message}\n\n${error.stack}`
  };
  
  try {
    await sgMail.send(msg);
  } catch (e) {
    console.error('Failed to send error notification:', e);
  }
}

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`PT Program Generator running on port ${PORT}`);
});
